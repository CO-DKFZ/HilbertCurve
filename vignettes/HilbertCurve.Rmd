<!--
%\VignetteEngine{knitr}
%\VignetteIndexEntry{Making Hilbert Curve}
-->

Making Hilbert Curve
========================================

**Author**: Zuguang Gu ( z.gu@dkfz.de )

**Date**: `r Sys.Date()`

-------------------------------------------------------------

```{r, echo = FALSE, message = FALSE}
library(markdown)
options(markdown.HTML.options = c(options('markdown.HTML.options')[[1]], "toc"))

library(knitr)
knitr::opts_chunk$set(
    error = FALSE,
    tidy  = FALSE,
    message = FALSE,
    fig.align = "center",
    fig.width = 6,
    fig.height = 6)
options(markdown.HTML.stylesheet = "custom.css")

options(width = 100)

on_cluster = grepl("tbi", Sys.info()["nodename"]) & Sys.info()["user"] == "guz"
```

[Hilbert curve](https://en.wikipedia.org/wiki/Hilbert_curve) is a type of space-filling curves
that folds one dimensional axis into a two dimensional space, but with still keeping the locality.
It has advantages to visualize data with long axis in following two aspects:

1. greatly improve resolution for the visualization;
2. easy to visualize clusters because generally data points in the axis will also be close in the 2D space. 

This package aims to provide an easy and flexible way to visualize data through Hilbert curve.
The implementation and example figures are based on following sources:

- http://mkweb.bcgsc.ca/hilbert/
- http://corte.si/posts/code/hilbert/portrait/index.html
- http://bioconductor.org/packages/devel/bioc/html/HilbertVis.html

```{r}
suppressPackageStartupMessages(library(HilbertCurve))
library(circlize)
set.seed(12345)
```

Following shows Hilbert curve with level 2, 3, 4, 5:

```{r, fig.width = 12, fig.height = 3, echo = FALSE}
grid.newpage()
pushViewport(viewport(layout = grid.layout(nr = 1, nc = 4)))
pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 1))
HilbertCurve(1, 100, level = 2, reference = TRUE, newpage = FALSE, title = "level = 2")
upViewport()
pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 2))
HilbertCurve(1, 100, level = 3, reference = TRUE, newpage = FALSE, title = "level = 3")
upViewport()
pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 3))
HilbertCurve(1, 100, level = 4, reference = TRUE, newpage = FALSE, title = "level = 4")
upViewport()
pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 4))
HilbertCurve(1, 100, level = 5, reference = TRUE, reference_gp = gpar(col = "grey"), 
    arrow = FALSE, newpage = FALSE, title = "level = 5")
upViewport()
upViewport()
```

Following heatmap shows distance between elements in the Hilbert curve. From left to right
and from top to bottom, the order is the natural order of data points on the axis and colors correspond 
to the distance for pair distance in the 2D space.
Basically, if data points are close in the one dimensional axis, they also have small 
distance in the Hilbert curve (regions around diagonals). There are some data points in [1, 256]
which are close to the data points in [768, 1024], but it is only because the curve folds back and
it is can easily distinguished once you know the structure of the curve.

```{r, fig.width = 7}
library(HilbertVis)
pos = HilbertVis::hilbertCurve(5)
mat = as.matrix(dist(pos))
library(ComplexHeatmap)

ht = Heatmap(mat, name = "dist", cluster_rows = FALSE, cluster_columns = FALSE, 
    show_row_names = FALSE, show_column_names = FALSE, 
    heatmap_legend_param = list(title = "euclidean_dist"))
draw(ht, padding = unit(c(5, 5, 5, 2), "mm"))
decorate_heatmap_body("dist", {
    grid.segments(c(0.25, 0.5, 0.75, 0, 0, 0), c(0, 0, 0, 0.25, 0.5, 0.75), 
	      c(0.25, 0.5, 0.75, 1, 1, 1), c(1, 1, 1, 0.25, 0.5, 0.75), gp = gpar(lty = 2))
    grid.text(rev(c(256, 512, 768, 1024)), 0, c(0, 256, 512, 768)/1024, just = "bottom", 
        rot = 90, gp = gpar(fontsize = 10))
    grid.text(c(1, 256, 512, 768, 1024), c(1, 256, 512, 768, 1024)/1024, 1, just = "bottom",
        gp = gpar(fontsize = 10))
})
```

## Basic settings

The **HilbertCurve** package provides a rather simple way to display the data in the Hilbert
curve. It provides functions to add low-level graphics and also support both "low-resolution"
and "high-resolution" modes.

Generally, customizing a Hilbert curve follows following steps:

```{r, eval = FALSE}
hc = HilbertCurve(...)  # initialize the curve
hc_points(hc, ...)      # add points 
hc_rect(hc, ...)        # add rectangles
hc_segments(hc, ...)    # add lines
hc_text(hc, ...)        # add text
```

`HilbertCurve()` is a constructor function and initializes the Hilbert curve. Following
example means initialize a Hilbert curve with level 4 which maps data ranging from 1 to 100
The function returns a `HilbertCurve` class instance and it can be used to add more graphics later.

```{r, eval = FALSE}
hc = HilbertCurve(1, 100, level = 4, reference = TRUE)
```

The curve can be though as a folded axis. When the coordinate for this folded axis is
initialized, low-level graphics can be added with specifying the positions.

There are several ways to specify the "positions" of the data points. First let's generate 
a random regions by **IRanges** package.

```{r}
x = sort(sample(100, 20))
s = x[1:10*2 - 1]
e = x[1:10*2]
ir = IRanges(s, e)
ir
```

Here `ir` contains intervals which are composed by positive integers. In later sections, 
you will see negative and numeric intervals are supported as well.

### Points

There are two modes for adding points. By default, every segment in the Hilbert curve are segmented
into several small segments and a circle is plotted at every small segments.

```{r}
hc = HilbertCurve(1, 100, level = 4, reference = TRUE)
hc_points(hc, ir)
```

The number of circles can be controlled by `np` (number of points per segment) and graphic parameters 
can be set by `gp`. Note under this mode, the size of points can only be changed by `np` argument.
Also you can choose different type of shapes for the points. There are some pre-defined shapes
that you can choose from: "circle", "square", "triangle", "hexagon", "star".

```{r}
hc = HilbertCurve(1, 100, level = 4, reference = TRUE)
hc_points(hc, ir, np = 3, gp = gpar(fill = rand_color(length(ir))),
    shape = sample(c("circle", "square", "triangle", "hexagon", "star"), length(ir), replace = TRUE))
```

If `np` is set less than 2 or `NULL`, the points will be plotted at the center of every interval in `ir`.
In this case, `size` argument is used to control the size of the points. This mode is useful
if you have a lot of small regions.

```{r}
hc = HilbertCurve(1, 100, level = 4, reference = TRUE)
hc_points(hc, ir, np = NULL, size = unit(runif(length(ir)), "cm"), pch = 16)
```

### Segments

Adding segments is straightforward. 

```{r}
hc = HilbertCurve(1, 100, level = 4, reference = TRUE)
hc_segments(hc, ir, gp = gpar(lwd = 5))
```

### Rectangles

Adding rectangles is straightforward. Note You cannot set the width or height of the rectangles. Rectangles are always located
at the turning points and have width or height equal to the length of the segments.

```{r}
hc = HilbertCurve(1, 100, level = 4, reference = TRUE)
hc_rect(hc, ir)
```

As you can see some rectangles are not full red. It is because these segments in the curve do not
full cover regions in `ir`, Averaging is applied in such segments. Actually it is also applicable
for the 'segmented circle' mode for `hc_points`.

Graphical values that correspond to `ir` are always represented as numeric values, such as size of points,
width of lines or even colors which can be converted to numeric RGB values. If a segment in the Hilbert
curve can not full overlap with some intervals in `ir`, these numeric parameters can be averaged.

There are three different modes for averaging which are controlled by `mean_mode` argument.
Following illustrates different settings for `mean_mode`:

```
      100     80    60     values in ir (e.g. red compoment for colors)
    ++++++   +++   +++++   ir
      ================     window (width = 16)
       4      3     3      overlap

    absolute: (100 + 80 + 60)/3
    weighted: (100*4 + 80*3 + 60*3)/(4 + 3 + 3)
    w0:       (100*4 + 80*3 + 60*3)/16
```

So use of the mode depends on specific scenario. For example, if `ir` corresponds to positions of genes,
then the mode of `w0` is perhaps a good choise. If `ir` corresponds to positions of CpG sites which is
has width of 1 and most of the time is sparse in genomic windows, then `absolute` is a correct choice.

### Text

Adding texts is straightforward. Note text is added at the center of each interval in `ir`.

```{r}
hc = HilbertCurve(1, 100, level = 4, reference = TRUE)
labels = sample(letters, length(ir), replace = TRUE)
hc_text(hc, ir, labels = labels, gp = gpar(fontsize = width(ir)*2+5))
```

### Combine low-level functions

With combination of these basic graphic functions, complicated graphics can be easily made:

```{r}
hc = HilbertCurve(1, 100, level = 4)
hc_segments(hc, IRanges(1, 100))   # This is an other way to add background line
hc_rect(hc, ir, gp = gpar(fill = rand_color(length(ir), transparency = 0.2)))
hc_points(hc, ir, np = 3)
hc_text(hc, ir, labels = labels, gp = gpar(fontsize = 16, col = "blue"))
```

## Non-integer positions

It doesn't matter if your positions are integers or not. Internally, rounding and zooming are applied
to ensure the accuracy.

Since the positions are not integers, you can specify the positions by `x1` and `x2`. All low-level graphical
funtions accept `x1` and `x2`.

```{r}
hc = HilbertCurve(0.1, 0.8, level = 4, reference = TRUE)
hc_points(hc, x1 = c(0.15, 0.55), x2 = c(0.25, 0.65))
```

Also, negative positions are allowed.

```{r}
hc = HilbertCurve(-100, 100, level = 4, reference = TRUE)
hc_points(hc, x1 = -50, x2 = 50)
```

## Add title and legends

Title are allowed by setting `title` argument. 
Legend can be passed to `legend` argument in `HilbertCurve()` as a `grob` object or a list of `grob` objects.
`ColorMapping` class in **ComplexHeatmap** package or `legendGrob()` in **grid** package can be used to create
a legend `grob`. Or you can consider to use `frameGrob()` and `packGrob()` to build a legend from ground.

Because width and height are enforced to be equal for the Hilbert curve, sometimes you may see blank spaces around
the curve.

```{r}
value = runif(length(ir))
col_fun = colorRamp2(c(0, 1), c("white", "red"))
cm = ColorMapping(col_fun = col_fun)
legend = color_mapping_legend(cm, plot = FALSE, title = "value")
hc = HilbertCurve(1, 100, reference = TRUE, title = "points", legend = legend)
hc_points(hc, ir, np = 3, gp = gpar(fill = col_fun(value)))
```

## Pixel mode

When the level is high (e.g. > 10), the whole 2D space will be almost completely filled by the curve and
it is impossible to add or visualize e.g. points on the curve. In this case, the 'pixel'
mode visualizes each tiny 'segment' as a pixel and maps values to colors. So the Hilbert
curve with level 11 will generate a PNG figure with 2048x2048 resolution. This is extremely
useful for visualize genomic data. E.g. If we make a Hilbert curve for human chromosome 1 with
level 11, then each pixel can represent 60bp (``249250621/2048/2048``) which is of very high resolution.

Under 'pixel' mode, if the current device is an interactive deivce, every time a new layer is added, 
the image will be add to the interactive device as a rastered image. 

```{r}
hc = HilbertCurve(1, 100, level = 9, mode = "pixel")
hc_layer(hc, ir)
```

Since you can only use color to map to other values, there is only one graphical setting `col`. 
You can add more than one layers, just remember to set transparent colors. And of course you can add title and legend to the plot.
Grid lines can be added to the plot for better distinguish blocks in the Hilbert curve.

```{r}
hc = HilbertCurve(1, 1000, level = 9, mode = "pixel", title = "pixel mode")
x = sample(1000, 100)
hc_layer(hc, x1 = x, x2 = x)
hc_layer(hc, x1 = 750, x2 = 850, col = "#0000FF40")
```

The Hilbert curve can be save as PNG figure by `hc_png()`, with resolution `2^level x 2^level`.

```{r, eval = FALSE}
hc_png(hc, file = "test.png")
```

## Examples

Visualize rainbow colors:

```{r}
col = rainbow(100)
hc = HilbertCurve(1, 100, level = 5)
hc_points(hc, x1 = 1:99, x2 = 2:100, np = 3, gp = gpar(col = col, fill = col))
```

or use the rectangles:

```{r}
hc = HilbertCurve(1, 100, level = 5)
hc_rect(hc, x1 = 1:99, x2 = 2:100, gp = gpar(col = col, fill = col))
```

Reproduce the ip...

```{r, eval = on_cluster, echo = 1:26}
library(RCurl)
library(ComplexHeatmap)
library(RColorBrewer)

html = httpGET("http://www.iwik.org/ipcountry/")
match = gregexpr("<td><a href=\".*?\">", html)
files = substr(rep(html, length(match[[1]])), match[[1]] + 13, match[[1]] + attr(match[[1]], "match.length")-3)
files = files[grep("cidr", files)]
cidr_list = lapply(files, function(f) {
    scan(paste0("http://www.iwik.org/ipcountry/", f), what = "character", sep = "\n", comment.char = "#", quiet = TRUE)
})
names(cidr_list) = gsub("(.*?).cidr", "\\1", files)

cidr_list = cidr_list[sapply(cidr_list, length) > 0]

country = rep(names(cidr_list), times = sapply(cidr_list, length))

ip = unlist(cidr_list, "r")

mat = t(as.matrix(data.frame(lapply(strsplit(ip, "\\.|/"), as.numeric))))
start = mat[, 1]*256^3 + mat[, 2]*256^2 + mat[, 3]*256 + mat[, 4]
width = sapply(mat[, 5], function(x) strtoi(paste(rep(1, 32 - x), collapse = ""), base = 2))

col = structure(rep("grey", length(cidr_list)), names = names(cidr_list))
top8_rate = sort(tapply(width, country, sum), decreasing = TRUE)[1:8]/256^4
top8 = names(top8_rate)
col[top8] = brewer.pal(8, "Set1")
top8_rate = paste0(round(top8_rate*100), "%")

cm = ColorMapping(levels = c(top8, "Others"), color = c(col[top8], "grey"))
lgd = color_mapping_legend(cm, title = "Top8 countries", labels = c(paste(top8, top8_rate), "Others"), plot = FALSE)
hc = HilbertCurve(0, 256^4, mode = "pixel", level = 9, legend = lgd)
hc_layer(hc, x1 = start, x2 = start + width, col = col[country])
if(file.exists("ip.png")) hc_png(hc, file = "ip.png")
```

```{r, echo = FALSE, eval = !on_cluster, results = "asis"}
cat("<p><center><img src='ip.png' /></center></p>\n")
```

Duration of Chinese dynasties.

```{r}
load(paste0(system.file("extdata", package = "HilbertCurve"), "/chinese_dynasty.RData"))

hc = HilbertCurve(min(chinese_dynasty[[2]]), max(chinese_dynasty[[3]]), title = "中国朝代（西周 ~ 清朝）", 
    title_gp = gpar(fontsize = 16, fontfamily = "Songti SC"))
hc_segments(hc, x1 = chinese_dynasty[[2]], x2 = chinese_dynasty[[3]], 
    gp = gpar(col = circlize::rand_color(nrow(chinese_dynasty), transparency = 0.2), 
        lwd = runif(nrow(chinese_dynasty), min = 1, max = 10)))
hc_text(hc, x1 = chinese_dynasty[[2]], x2 = chinese_dynasty[[3]], labels = chinese_dynasty[[1]], 
    gp = gpar(fontsize = (chinese_dynasty[[3]] - chinese_dynasty[[2]])/500 * 10 + 8, 
        fontfamily = "Songti SC"))
```

## GenomicHilbertCurve: specific for genomic data

To make it easy with genomic data which is always stored as a data frame for a `GRanges` object,
the package provides specific functions to deal with it. `GenomicHilbertCurve()` initialize the 
Hilbert curve by specifying chromosomes or specific background regions. After that, the data
frame or `GRanges` object which contains genomic positions can be mapped to the curve afterwards.

Following functions can be applied on the `GenomicHilbertCurve` object, and the second argument
should be a data frame or a `GRanges` object.

```
hc_points()
hc_rect()
hc_segments()
hc_text()
hc_layer()
```

One major feature is multiple chromosomes (or genomic categories) can be put into one same curve.

Following illustrates several examples of making genome-level Hilbert curves.

Genes on chromosome 1 (RefSeq genes for human, hg19). Here random colors are used
to represent to different genes.

```{r}
load(system.file("extdata", "refseq_chr1.RData", package = "HilbertCurve"))
hc = GenomicHilbertCurve(chr = "chr1", level = 5, reference = TRUE, 
    reference_gp = gpar(lty = 1, col = "grey"), arrow = FALSE)
hc_segments(hc, g, gp = gpar(lwd = unit(6, "mm"), col = rand_color(length(g))))
```

Following two figures compare sequence conservations. Data are from [here](http://genome.ucsc.edu/cgi-bin/hgTables?hgsid=434791817_tLOpTRgCwS2hR4uJ2cDjGaHUQEKj&clade=mammal&org=Human&db=hg19&hgta_group=compGeno&hgta_track=placentalChainNet&hgta_table=0&hgta_regionType=genome&position=chr16%3A81839239-81902938&hgta_outputType=wigData&hgta_outFileName=).

```{r}
chr1_len = 249250621
load(system.file("extdata", "mouse_net.RData", package = "HilbertCurve"))
seqlengths(mouse) = chr1_len
nonmouse = gaps(mouse); nonmouse = nonmouse[strand(nonmouse) == "*"]
gr = c(mouse, nonmouse)
col = c(rep("red", length(mouse)), rep("yellow", length(nonmouse)))
hc = GenomicHilbertCurve(chr = "chr1", level = 6)
hc_points(hc, gr, np = 3, gp = gpar(col = col, fill = col))

load(system.file("extdata", "zebrafish_net.RData", package = "HilbertCurve"))
seqlengths(zebrafish) = chr1_len
nonzebrafish = gaps(zebrafish); nonzebrafish = nonzebrafish[strand(nonzebrafish) == "*"]
gr = c(zebrafish, nonzebrafish)
col = c(rep("red", length(zebrafish)), rep("yellow", length(nonzebrafish)))
hc = GenomicHilbertCurve(chr = "chr1", level = 6)
hc_points(hc, zebrafish, np = 3, gp = gpar(col = col, fill = col))
```

GC percent on chromosome 1, under "normal" mode:

```{r, eval = on_cluster, echo = 1:5}
df = read.table(pipe("awk '$1==\"chr1\"' ~/HilbertCurveTest/hg19_gc_percent_window1000.bed"))
col_fun = colorRamp2(c(0, 500, 1000), c("green", "#FFFFCC", "red"))
hc = GenomicHilbertCurve(chr = "chr1", level = 6)
hc_points(hc, df, np = 3, gp = gpar(fill = col_fun(df[[5]]), col = col_fun(df[[5]])))
hc_rect(hc, reduce(g), gp = gpar(fill = "#00000020", col = NA))
if(file.exists("gc_percent_chr1_points.png")) hc_png(hc, file = "gc_percent_chr1_points.png")
```

```{r, echo = FALSE, eval = !on_cluster, results = "asis"}
cat("<p><center><img src='gc_percent_chr1_points.png' /></center></p>\n")
```

GC percent on chromosome 1, under "pixel" mode:

```{r, eval = on_cluster, echo = 1:3}
hc = GenomicHilbertCurve(chr = "chr1", level = 9, mode = "pixel")
hc_layer(hc, df, col = col_fun(df[[5]]))
hc_layer(hc, reduce(g), col = "#00000020")
if(file.exists("gc_percent_chr1.png")) hc_png(hc, file = "gc_percent_chr1.png")
```

```{r, echo = FALSE, eval = !on_cluster, results = "asis"}
cat("<p><center><img src='gc_percent_chr1.png' /></center></p>\n")
```

Following data are from http://genboree.org/EdaccData/Release-9/sample-experiment/Lung/

First is the distribution of histone marks as well as the gene regions (shadow).

```{r, eval = FALSE}
library(GetoptLong)
plot_histone_mark = function(mark) {
	df = read.table(pipe(qq("awk '$5>0 && $1==\"chr1\"' ~/HilbertCurveTest/UCSD.Lung.@{mark}.STL002.bed")), sep = "\t")
	col_fun = colorRamp2(c(0, quantile(df[[5]], 0.99)), c("white", "red"))
	hc = GenomicHilbertCurve(chr = "chr1", level = 9, mode = "pixel")
	hc_layer(hc, df, col = col_fun(df[[5]]))
    hc_layer(hc, reduce(g), col = "#00000010")
    return(invisible(hc))
}
```

H3K27ac histone mark:

```{r, eval = on_cluster, echo = 1}
plot_histone_mark("H3K27ac")
if(file.exists("H3K27ac_chr1.png")) hc_png(hc, file = "H3K27ac_chr1.png")
```

```{r, echo = FALSE, eval = !on_cluster, results = "asis"}
cat("<p><center><img src='H3K27ac_chr1.png' /></center></p>\n")
```

H3K36me3 histone mark. (H3K36me3 is found in actively transcribed gene bodies)

```{r, eval = on_cluster, echo = 1}
plot_histone_mark("H3K36me3")
if(file.exists("H3K36me3_chr1.png")) hc_png(hc, file = "H3K36me3_chr1.png")
```

```{r, echo = FALSE, eval = !on_cluster, results = "asis"}
cat("<p><center><img src='H3K36me3_chr1.png' /></center></p>\n")
```

H3K4me3 histone mark. (H3K4me3 is found in actively transcribed promoters, particularly just after the transcription start site)

```{r, eval = on_cluster, echo = 1}
plot_histone_mark("H3K4me3")
if(file.exists("H3K4me3_chr1.png")) hc_png(hc, file = "H3K4me3_chr1.png")
```

```{r, echo = FALSE, eval = !on_cluster, results = "asis"}
cat("<p><center><img src='H3K4me3_chr1.png' /></center></p>\n")
```

H3K9me3 histone mark. (H3K9me3 is found in constitutively repressed genes)

```{r, eval = on_cluster, echo = 1}
plot_histone_mark("H3K9me3")
if(file.exists("H3K9me3_chr1.png")) hc_png(hc, file = "H3K9me3_chr1.png")
```

```{r, echo = FALSE, eval = !on_cluster, results = "asis"}
cat("<p><center><img src='H3K9me3_chr1.png' /></center></p>\n")
```

Coverage for RNAseq.

```{r, eval = on_cluster, echo = 1:6}
df = read.table(pipe(qq("awk '$5>0 && $1==\"chr1\"' ~/HilbertCurveTest/UCSD.Lung.mRNA-Seq.STL002.bed")), sep = "\t")
df[[5]] = log(df[[5]] + 1)
col_fun = colorRamp2(c(0, quantile(df[[5]], 0.99)), c("white", "red"))
hc = GenomicHilbertCurve(1, chr1_len, level = 9, mode = "pixel")
hc_layer(hc, df, col = col_fun(df[[5]]))
hc_layer(hc, reduce(g), col = "#00000010")
```

```{r, echo = FALSE, eval = !on_cluster, results = "asis"}
cat("<p><center><img src='RNASeq_coverage_chr1.png' /></center></p>\n")
```

Methylation, blue corresponds to un-methylation, red corresponds to full-methylation.

```{r, eval = on_cluster, echo = 1:5}
df = read.table(pipe("awk '$1==\"chr1\"' ~/HilbertCurveTest/UCSD.Lung.Bisulfite-Seq.STL002.bed"), sep = "\t")
col_fun = colorRamp2(c(0, 0.5, 1), c("blue", "white", "red"))
hc = GenomicHilbertCurve(chr = "chr1", level = 9, mode = "pixel")
hc_layer(hc, df, col = col_fun(df[[5]]), mean_mode = "absolute")
hc_layer(hc, reduce(g), col = "#00000010")
if(file.exists("methylation_chr1.png")) hc_png(hc, file = "methylation_chr1.png")
```

```{r, echo = FALSE, eval = !on_cluster, results = "asis"}
cat("<p><center><img src='methylation_chr1.png' /></center></p>\n")
```

### Put multiple chromosomes in one plot

We demonstrated how to visualize one single chromosome through Hilbert curve, but sometimes
we also want to put all chromosomes into one plot to get rid of reading too many plots simutaneously.
One solution is to construct a 'huge' chromosome which merges all real chromosomes.

```{r, eval = on_cluseter, echo = 1:5}
df = read.table(pipe("awk '$1==\"chr1\"' ~/HilbertCurveTest/cnv.txt"), sep = "\t")
df = df[c(1, 2, 2, 3)]
hc = GenomicHilbertCurve(chr = paste0("chr", c(1:22, "X", "Y")), level = 9, mode = "pixel")
col_fun = colorRamp2(c(-0.7, 0, 0.7), c("green", "white", "red"))
hc_layer(hc, df, col = col_fun(df[[4]]), mean_mode = "absolute", grid_line = 3)
hc_layer(hc, reduce(g), col = "#00000010")
if(file.exists("cnv_all_chromosomes.png")) hc_png(hc, file = "cnv_all_chromosomes.png")
```

```{r, echo = FALSE, eval = !on_cluster, results = "asis"}
cat("<p><center><img src='cnv_all_chromosomes.png' /></center></p>\n")
```

Also a map which shows the chromosome positions in Hilbert curve is necessary.

```{r}
hc_map(hc)
```

If background is defined as a list of regios, ...

## Session info

```{r}
sessionInfo()
```
